# CSRF

CSRF（Cross-site request forgery）即跨站请求伪造，攻击者利用受害者在被攻击网站已经获取的注册凭证，向被攻击网站发送跨站请求，达到冒充用户对被攻击的网站执行某项操作的目的。

首先假设某银行网站有 GET 接口 `http://bank.com/transfer` 可接收 `id` 和 `amount` 参数，用与向某用户转账。攻击者诱导用户浏览某个网站，页面中包含 `<img src="http://bank.com/transfer?id=0011&amount=100"/>` 图片，图片会自动发送请求并携带 Cookie，达到转账的目的。

## 攻击方式

除部分标签 `src` 自动 GET 外，表单提交的 POST 请求同样会携带 Cookie。

通常，GET 攻击可能来自攻击者页面，也可能就来源于被攻击的网站，如博客类网站嵌入图片进行 GET 攻击。但 POST 攻击一般是攻击者自行构建表单页面进行攻击。因此对于修改、删除等操作，应尽量使用对应的非 GET 方法进行请求。

## 防范

要进行 CSRF 攻击，需要满足：
- 用户在被攻击系统中保持登录状态
- 用户在被攻击系统或第三方系统触发攻击请求

### 同源检测

针对非 `bank.com` 域下的请求，需要进行限制。HTTP 的 `Referer` 请求头会携带发起请求的域名地址，通过判断该请求头的值，确定是否是第三方域名下的请求，通过 CSP 进行限制。

`Referer` 字段依赖浏览器携带正确的值，无法保证浏览器的具体实现和安全性。这种方案无法阻止本域下的攻击。

### `Samesite` 属性

Chrome 51 版本开始，可接收 `Set-Cookie` 的 `Samesite` 属性，用于防止 CSRF 攻击，`Samesite` 有 3 个可选值：
- `Strict`：严格模式，完全禁止第三方请求的 Cookie 携带，仅网页域请求目标同源时，才会携带 Cookie
- `Lax`：默认模式，第三方站点以 `<link>` 预加载、`<a>` 链接或 GET 提交表单这三种方式访问请求目标时，会携带 Cookie，其它形式的第三方站点请求，不携带 Cookie
- `None`：原始方式，任何情况都提交 Cookie

由于是 Google 提出和实现的方案，其兼容性存在问题。

### CSRF Token

服务器返回一个唯一 Token，通过 WebStorage 或其它非 Cookie 方式存储 Token 到浏览器本地，后续请求需要同时携带 Cookie 和 Token。攻击者无法获取 Token，也就无从下手。

这种方案需要服务器对提交的请求进行验证，服务器需要存储 Cookie 和 Token 的对应关系。

### 双重 Cookie

CSRF Token 方案增加了服务器端的复杂性，尤其是分布式服务。因此根据 CSRF Token 的原理，让 Cookie 在自动携带时，同时将其手动添加到 AJAX 或表单请求的参数中。手动添加到参数这一步，攻击者无法模仿，由此保证安全性。

双重 Cookie 可以缓解服务端的压力，但如果系统有 XSS 或其它漏洞，这种方式无法保证安全。

Cookie 的安全限制在于，只能在本域名或子域名访问 Cookie 值，兄弟子域无法访问。双重 Cookie 难以做到子域名的隔离。
