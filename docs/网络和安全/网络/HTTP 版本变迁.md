# HTTP 版本变迁

超文本传输协议（Hyper Text Transfer Protocol，HTTP）是运行于 TCP/IP 协议之上的一个应用层协议，它规定了客户端与服务端之间的通信格式和所占用的服务端口。HTTP 使用 `80` 端口，HTTPS 使用 `443` 端口。

### HTTP/0.9

HTTP/0.9 版本是 1991 年发布的版本，仅支持 GET 请求，规定服务器只能回应 HTML 文档。该版本不包含 HTTP 头、状态码等内容。这个版本的局限性很明显，HTTP/0.9 很快被更完善的版本所取代。

## HTTP/1.0

1996 年，HTTP/1.0 版本发布，其改进之处：
- 每个请求命令的尾部必须添加协议版本信息 `HTTP/1.0`
- 请求和响应都可以使用规定的首部
- 响应必须包含状态码
- 新增 POST 和 HEAD 请求方法

首部为 HTTP 添加了各种功能，如 `Content-Type: <MIME type>`、`Content-Encoding/Accept-Encoding`、`Expires` 等使 HTTP 可以传输任何类型的文件、压缩文件体积、资源缓存等。

### 缺点

HTTP/1.0 版本的显著缺点是，一个 TCP 连接只能处理一次资源的传输，数据响应完毕就关闭 TCP 连接。如果要请求其它资源，就必须新建一个 TCP 连接。新建 TCP 连接需要进行三次握手，加上 TCP 慢启动的特性，导致 HTTP/1.0 版本的性能较差。

为解决这个问题，浏览器在请求时使用一个非标准的 `Connection: keep-alive` 请求头，告知服务器不要关闭 TCP 连接，以便其它请求复用，服务器会响应同样的头。这个 TCP 连接会直到客户端或服务器主动关闭连接。但这并不是标准首部，不同的实现标准导致行为可能不一致。


## HTTP/1.1

1997 年，HTTP/1.1 版本发布，它进一步完善了 HTTP 协议。

### 持久连接

TCP 连接默认不关闭，可以被多个请求复用，不需要声明 `Connection: keep-alive`。客户端或服务器发现对方一段时间没有活动，就可以主动关闭连接。通常，客户端在发出最后一个请求时，发送 `Connection: close`，明确要求服务器关闭 TCP 连接。

### 管道机制

在同一个 TCP 连接中，客户端可以**同时发出多个请求**，但服务器还是**按照请求的顺序进行响应**。

管道机制要求服务器使用 `Content-length` 响应头声明本次请求的响应数据的长度，以区分返回数据包是属于哪一个请求的响应，超出该字节的后续字节属于下一个请求的响应。

### 分块传输编码

请求或响应头信息中有 `Transfer-Encoding: chunked` 字段，表明响应将由数量未定的数据块组成：
- 每个非空的数据块之前，会有一个 16 进制的数值，表示这个块的长度
- 最后是一个大小为 0 的块，表示本次响应的数据发送完毕

对大文件使用分块传输，服务器不需要等待数据生成完毕才发送响应数据，可以边生成边发送，提高了效率。

### 其它功能

- 新增了请求方法：PUT、PATCH、HEAD、OPTIONS、DELETE
- 新增 `Cache-Control` 头控制缓存
- 增加 `Host` 请求头用来指定服务器的域名，`Host` 请求头可以将请求发往同一台服务器上的不同网站，为虚拟主机的兴起提供基础。

### 缺点

虽然 HTTP/1.1 版本允许复用 TCP 连接，但是同一个 TCP 连接中，所有的数据通信是按次序进行的。服务器只有处理完一个响应，才会处理下一个响应。如果某个响应费时较长，后续的响应无法得到及时的处理，这称为 “**队头堵塞**”。

为避免队头堵塞，可以采用两种方案：
- 减少请求数量：雪碧图、脚本合并、样式表合并等
- 增加持久连接数量：将页面资源分散到不同的域名，浏览器对**同一域名**的 TCP 连接通常最多为 6 个

## HTTP/2

2015 年，HTTP/2 版本发布，它是基于 Google 的 SPDY 协议改进而来的。它保留了 HTTP/1.1 的语义，但是改变了数据的格式和传输方式。


### 头部压缩

HTTP 协议的报文由首部加实体构成，实体的压缩可由 `Content-Encoding` 完成。首部通常有许多字段值是重复的，但每次请求和响应都会携带，HTTP/2 使用 HPACK 算法对首部进行压缩，减少传输的数据量。

HTTP/2 为高频出现的 `61` 组首部建立了一张**静态表**：

![HTTP2-static-table](/HTTP版本变迁/HTTP2-static-table.webp)

HTTP/2 根据出现的频率将 ASCII 码编码为 **Huffman 编码表**，静态表中值可以动态变化的首部，在使用索引的同时还会使用 Huffman 编码压缩其值。

不在静态表范围内的首部，需要自行构建**动态表**，索引从 `62` 开始。首次发送动态首部，客户端和服务器都会更新自己的动态表，添加一个新的索引号，下一次交互不需要发送重复内容的该首部，只需发送存储的的索引号即可。

HTTP/2 通过头部压缩，可以有效地减少首部的冗余和重复，节省带宽和资源，提升用户体验。

:::tip 注意
动态表会占用内存，过大的内存占用会影响服务器性能，服务器通过 `http2_max_requests` 配置同一 TCP 连接上的请求数量，避免动态表无限增大。
:::

### 二进制帧

HTTP/1.1 的头信息为文本，实体可以是文本或二进制数据。HTTP/2 会将所有传输的信息分割为更⼩的消息并封装在帧中，并对它们采⽤⼆进制格式的编码。二进制帧是 HTTP/2 中的最小传输单位，也是多路复用的基础。

![HTTP2-binary-frame](/HTTP版本变迁/HTTP2-binary-frame.webp)


一个二进制帧包含**帧头**和**帧数据**两个主要部分：
- 帧头：`9Bytes` 大小，包含帧的长度、类型、标志位、流标识符
- 帧数据：通过 HPACK 算法压缩过的 HTTP 头部和实体

#### 帧类型

HTTP/2 共定义了 `10` 中类型的帧，一般分为数据帧和控制帧两类：

![HTTP2-frame-types](/HTTP版本变迁/HTTP2-frame-types.webp)

#### 标志位

`8bits` 的标志位通常用于携带简答的控制信息，如：
- `END_HEADERS`：表示头数据结束标志，相当于 HTTP/1.1 的换行 `\r\n`
- `END_Stream`：表示流数据发送结束，后续不会再有数据帧
- `PRIORITY`：表示流的优先级

#### 流标识符

帧头最后 4 个字节是流标识符（stream identifier），但最高位被保留不用，只有 31 位可以使用，因此流标识符的最大值是 `2^31`。流标识符的作用是用来标识该帧属于哪个流，接收方可以根据流标识符有序组装信息。


### 多路复用与并发传输

HTTP/2 针对同一域名下的所有请求和响应只建立一个 TCP 连接，实现了多路复用。多路复用减少了 TCP 连接的数量和建立的开销，有效解决了 HTTP/1.1 中的队头阻塞问题。

HTTP/2 使用流来表示一个双向的或者单向的消息（message），每个流都有一个唯一的整数标识符（stream identifier）和优先级。在同一个流内，可以同时（并行）**发送和接收**二进制帧，并且帧的发送与接收都是按照顺序进行。不同流之间的发送和接收，会根据优先级抢占 TCP，**交错**进行。

流可以被客户端或服务器创建、使用、暂停、恢复或取消，主动创建流的是：
- 客户端：stream identifier 为奇数
- 服务端：stream identifier 为偶数

HTTP/1.1 无法实现多路复用的根本原因是它是基于文本分割解析的协议，而不是二进制帧的协议。请求和响应报文都是由起始行、首部和实体（可选）组成，各部分之间以文本换行符分隔。这样的报文格式不利于在同一个 TCP 连接上发送多个请求和响应，因为它们的生命周期不能重叠，只能串行执行。

HTTP/2 是基于二进制帧的协议，它将请求和响应数据分割为更小的帧，并且它们采用二进制编码。每个帧都有一个流标识符，用来区分不同的请求和响应。这样的报文格式可以在同一个 TCP 连接上发送多个请求和响应，因为它们的生命周期可以重叠，可以并行执行。

### 服务器推送

HTTP/2 允许服务器在响应客户端请求时主动发送额外的资源，例如 HTML 文档中引用的样式表或脚本文件。这样，客户端就不需要再发起额外的请求，从而提高了性能。

服务器推送与 `preload` 的的性能差距可能并不显著，如果使用推送功能提前推送静态资源，可能造成预判错误导致的服务器资源和带宽浪费。

### 缺点

HTTP/2 是基于字节流协议 TCP 来传输数据的，TCP 层必须保证收到的字节数据是完整且连续的，这样内核才会将缓冲区里的数据返回给 HTTP 应用。因此当**前一个字节数据**没有到达时，后续收到的字节数据只能存放在内核缓冲区里，只有等到前一个字节数据到达时，HTTP 应用层才能从内核中拿到数据。

因此，如果某一个流有 TCP 报文丢失，整个 TCP 都要等待重传，那么即使接收到其它流的报文，应用层也无法读取。对 HTTP 层面，还是有队头阻塞的问题存在。

## HTTP/3

2020 年，HTTP/3 版本发布，它是基于 Google 的 QUIC 协议改进而来的。它保留了 HTTP/2 的语义，但是改变了底层的传输协议。

### 使用 QUIC 协议

HTTP/3 使用 QUIC 协议代替了 TCP 协议，作为 HTTP 的底层传输协议。QUIC 是一种基于 UDP 的多路复用的传输协议，它具有以下优点：
- 无队头阻塞：每一个数据包都有一个唯一标识，某个流中的数据包丢失，不会影响其它流的正常读取
- 重传：QUIC 可以在丢包或超时的情况下快速重传数据，而不需要等待 TCP 的超时重传机制
- 快速握手：QUIC 整合了 UDP 和 TLS，仅用 1RTT 确认双方的**连接 ID**，并完成 TLS 版本协商和加密密钥的交换
- 连接迁移：借助**连接 ID**，QUIC 可以在网络切换时保持连接的状态，而不需要重新建立连接
- 拥塞控制：QUIC 可以根据网络状况动态调整数据发送的速率，避免过度拥塞或者浪费带宽 

### 其他功能

HTTP/3 使用二进制帧格式来编码请求和响应的数据，帧的类型和结构相对于 HTTP/2 进行了优化和精简。

HTTP/3 的静态表键值对更丰富。
