---
title: "浅谈 GC"
author: "GeekKery"
date: 2021-02-19T15:04:44+08:00
tags: ["JavaScript"]

---

内存的生命周期包括分配内存、使用内存和释放内存。有些语言（比如 C 语言）必须手动分配和释放内存，JavaScript 的内存分配过程是在做变量声明赋值时自动完成的。变量完成内存分配之后程序才可以使用进行读写。当程序不需要再使用某些变量时，它们占用的内存就会进行释放，腾出空间。

## 内存溢出

程序的运行需要内存，只要程序提出要求，操作系统或者运行时（Runtime）就必须供给内存。程序运行过程中申请的内存大于系统能够提供的内存，导致程序无法申请到足够的内存，这就是内存溢出（Out Of Memory）。

## 内存泄漏

**不再用到的内存，没有及时释放，就叫做内存泄漏（Memory Leak），内存泄漏与大小无关，并非导致程序卡顿、崩溃才能叫做内存泄漏**。

内存泄漏的堆积，会使内存占用越来越高，轻则影响系统性能，重则导致进程崩溃，尤其是持续运行的服务进程（Daemon）。

在 Chrome 浏览器的 Performance 功能中，使用 Memory 选项可以帮助开发者查看内存占用，如果内存不是趋于平稳，而是一直上升，则可能发生了内存泄漏。在 Performance 功能中，也可以手动进行垃圾回收。

Node.js 提供了 process.memoryUsage 方法，process.memoryUsage 返回一个对象，包含了 Node.js 进程的内存占用信息，该对象包含四个字段，单位是字节。判断内存泄漏，以 heapUsed 字段为准。

```JavaScript
console.log(process.memoryUsage())
// Prints:
// {
//  rss: 4935680,
//  heapTotal: 1826816,
//  heapUsed: 650472,
//  external: 49879,
//  arrayBuffers: 9386
// }
```

> - rss（resident set size）：所有内存占用，包括指令区和堆栈；
> - heapTotal：”堆“占用的内存，包括用到的和没用到的；
> - heapUsed：用到的堆的部分；
> - external： V8 引擎内部的 C++ 对象占用的内存；
> - arrayBuffers：分配给 ArrayBuffers 和 SharedArrayBuffers 的内存，包括所有 Node.js 缓冲区。

## 垃圾回收机制

释放内存需要判定哪些变量是需要被回收的，对于像 JavaScript 这样的高级语言来说，内存释放过程是由垃圾回收器自动完成的，垃圾回收器会按照固定的时间间隔，周期性地找出不再继续使用的变量，然后释放其占用的内存。JavaScript 用于确定可回收内存的方法主要有两种：引用计数与标记清除。无论哪种回收机制，全局变量的生命周期直至浏览器卸载页面才会结束，也就是说**全局变量不会被当成垃圾回收**。

### 引用计数

引用计数是被弃用的垃圾回收策略。老版本 IE 的 BOM 和 DOM 对象是使用 C++ 以 COM 对象的形式实现的，COM 的垃圾回收采用的就是引用计数策略。

引用计数的基本原理是，保存每个对象的引用计数，当引用发生增减时对计数进行更新。引用计数的增减，一般发生在变量赋值、对象内容更新、函数结束（局部变量不再被引用）等时间节点。当一个对象的引用计数变为 0 时，则说明它将来不会再被引用，因此可以释放相应的内存空间。

```javascript
const arr = [1, 2, 3, 4];
console.log('hello world');
```

数组 [1, 2, 3, 4] 是一个值，会占用内存。变量 arr 是仅有的对这个值的引用，因此这个数组的被引用次数为 1。尽管后面的代码没有用到 arr 变量，它还是会持续占用内存。

```javascript
let arr = [1, 2, 3, 4];
console.log('hello world');
arr = null;
```

上面代码中，将 arr 重置为 null，就解除了对 [1, 2, 3, 4] 的引用，引用次数变成了 0，这部分内存就可以被垃圾回收器释放。

因此，即使有了垃圾回收机制，开发者还是要关注内存占用：那些很占空间的值，一旦不再用到，必须检查是否还存在对它们的引用；如果是的话，就必须手动解除引用。

实现容易是引用计数算法最大的优点，相当具有普遍性。采用引用计数策略，当对象不再被引用的瞬间就会被释放，由于释放操作是针对每个对象个别执行的，因此和其它算法相比，由 GC 而产生的中断时间就比较短。

而引用计数最大的缺点，就是无法释放循环引用的对象。以下 marry 函数执行完毕后，bob 和 alice 两个对象由于互相引用，因此引用计数都为 1，即使后续不会再被使用到，也会持续占用内存，不被释放。当我们不使用它们的时候，需要手动切断引用才能回收内存。

```javascript
function marry(){
  let bob = {};
  let alice = {};
  bob.wife = alice; 		// bob 引用 alice
  alice.husband = bob;	// alice 引用 bob

  return "They are married！";
}

marry();
```



另外，引用计数并不适合并行处理。如果多个线程同时对引用计数进行增减的话，引用计数的值就可能会不一致，导致内存错误。为了避免这种情况的发生，对引用计数的操作必须采用独占的方式来进行。如果引用操作频繁发生，每次都要使用加锁等并发控制机制的话，其开销也是不可小觑的。综上所述，引用计数方式的原理和实现虽然简单，但缺点也很多，因此基本上不再被使用。现在，依然采用引用计数方式的语言主要有 Perl 和 Python，但它们为了避免循环引用的问题，都配合使用了其他的 GC 机制。这些语言中，GC 基本上是通过引用计数方式来进行的，但偶尔也会用其他的算法来执行 GC，这样就可以将引用计数方式无法回收的那些对象处理掉。

## 标记清除

标记清除（Mark and Sweep）是最早开发出的 GC 算法（1960年）。Node.js 的 global 对象和 JavaScript 的 window 对象，被称作”根“，标记清除首先从根开始，将可能被引用的对象用递归的方式进行标记，标记阶段完成时，被标记的对象就被视为”存活“对象。然后将没有标记到的对象作为垃圾进行回收。

零引用的对象肯定是需要被回收的，反过来，需要被回收的对象却不一定是零引用（循环引用）。因此标记清除可以有效解决循环引用的问题。在上面的循环引用示例中，marry 函数调用返回之后，两个对象从全局对象出发无法获取。因此，它们将会被垃圾回收器回收。

从 2012 年起，所有现代浏览器都使用了标记清除垃圾回收算法。所有对 JavaScript 垃圾回收算法的改进都是基于标记清除算法的改进（如 V8 引擎的垃圾回收机制）。
