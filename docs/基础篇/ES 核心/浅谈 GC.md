# 浅谈 GC

程序的运行需要内存，只要程序提出要求，操作系统或者运行时就必须供给内存。程序运行过程中申请的内存大于系统能够提供的内存，导致程序无法申请到足够的内存，会造成内存溢出（Out of Memory）。不再用到的内存，没有及时释放，就叫做内存泄漏（Memory Leak）。

```JS
let obj = { prop: 'value' }
obj = [1, 2, 3, 4, 5]
```

以上代码在执行时：
1. 栈内存中存放指针，指向堆内存中的对象实体 `{ prop: 'value' }`
2. 被重新赋值一个数组时，栈中的指针指向堆内存中新的数组实体 `[1, 2, 3, 4, 5]`
3. 对象实体 `{ prop: 'value' }` 不会再被使用到，应该清理其所占的内存空间

如果没有对不再使用的内存空间进行清理，就会发生内存泄漏。内存泄漏的堆积，会使内存占用越来越高，轻则影响系统性能，重则导致进程崩溃，尤其是持续运行的服务进程（Daemon）。

ES 具有自动垃圾回收（Garbage Collecation）机制，宿主环境会负责内存的分配和回收。垃圾回收器会按照固定的时间间隔，周期性地找出不再继续使用的变量，然后释放其占用的内存。

## 引用计数

引用计数是**被弃用**的垃圾回收策略。引用计数将 “对象不再需要” 与 “对象不被任何对象引用” 挂钩，跟踪记录每个变量值被引用的次数：
- 声明变量，并将引用类型值赋值给该变量，引用次数为 `1`
- 同一引用类型值被赋值给另一变量，引用次数 `+1`
- 同一引用类型值被其它值覆盖，引用次数 `-1`
- 当值的引用次数变为 `0` 时，说明没有变量在使用值，无法被访问，GC 在运行时会清理掉引用次数为 `0` 的值占用的内存

```JS
let arr = [1, 2, 3, 4]
console.log('Hello, World!')
// arr = null
```

数组 `[1, 2, 3, 4]` 是一个值，会占用内存。变量 `arr` 是仅有的对这个值的引用，因此这个数组的被引用次数为 `1`。尽管后面的代码没有用到 `arr` 变量，但数组还是会持续占用内存。如果执行 `arr = null`，就解除了 `arr` 对 `[1, 2, 3, 4]` 的引用，引用次数变成了 `0`，这部分内存就可以被垃圾回收器释放。

以下代码执行完后，由两个参数对象由于互相引用使得其引用计数为 `2`，会造成即使后续不会再被使用到，也会持续占用内存，不被释放，这就是引用计数最大的缺点---无法处理循环引用。

```JS
function marry(man, woman) {
  man.wife = woman
  woman.husband = man
  return 'Hello, World!'
}
marry({ name: 'John' }, { name: 'Ann' })
```

### 小结

引用计数的优点在于容易实现，当对象不再被引用时，其内存会被立即释放，由于释放操作是针对每个对象个别执行的，由 GC 而产生的中断时间就比较短。

引用计数最大的缺点是无法释放循环引用的对象。同时，引用计数也不适合并行处理，如果多个线程同时对引用计数进行增减的话，引用计数的值就可能会不一致，导致内存错误。为了避免这种情况的发生，对引用计数的操作必须采用独占的方式来进行。如果引用操作频繁发生，每次都要使用加锁等并发控制机制的话，其开销也是不可小觑的。



## 可达性（Reachability）

为理解标记清除策略，需要先了解 “可达性” 的概念。Node.js 的 `global` 对象和 JavaScript 的 `window` 对象，被称作 “根” 对象。

“可达值” 指**存储在内存中的、可访问或可用的值**：
 - 当前执行函数的局部变量和参数
 - 当前嵌套调用链上的其它函数和它们的局部变量和参数
 - 全局变量
 - 可通过根对象访问的值，如全局对象的一个属性是另一个对象，这个属性指向的对象是可达的

可达值在函数作用域的定义都使用了 “当前执行” 进行限制，实际上，在函数在执行完毕后，如果没有返回函数造成闭包，那么此时整个函数作用域将不具备可达性。

## 标记清除

标记清除（Mark and Sweep）是目前 ES 引擎中最常用的 GC 策略，各大浏览器的 GC 算法都是基于标记清除的改进和优化。

**标记清除从根对象开始，将具有可达性的对象用递归的方式进行标记，然后将没有标记到的对象作为垃圾进行回收。**

根据标记清除算法，`0` 引用的对象一定会被回收，而需要被回收的对象却不一定是零引用。前述 `marry()` 函数执行完毕之后，尽管函数作用域中的对象存在循环引用，但这个函数作用域整体不具备可达性，即通过根对象始终无法访问，因此这个函数作用域整体会成为一个孤岛而不被标记，等待 GC。

![unreachable](/浅谈%20GC/unreachable.svg)

:::tip 归纳
无论哪种回收策略，**全局变量永远不会被当成垃圾回收**。
:::

### 小结

引用计数和标记清除在释放内存后，剩余对象的内存位置依旧不变，会导致空闲内存空间不连续，出现许多内存碎片。

剩余空闲内存不是一整块，而是由不同大小内存组成的内存列表。在分配大小为 `size` 的内存时，需要对空闲内存列表进行一次单向遍历找出 `>=size` 的块才能为其分配，主要的三种分配策略：
- `First-fit`：找到 `>=size` 的块立即返回
- `Best-fit`：遍历整个空闲列表，返回 `>=size` 的最小分块
- `Worst-fit`：遍历整个空闲列表，找到最大的分块，将其切成两部分，其中一部分大小为 `size` 并将该部分返回

![memory-fit](/浅谈%20GC/memory-fit.png)

内存碎片化导致需要遍历空闲内存列表，选取最适合的内存进行分配，即使是 `First-fit` 分配策略，时间复杂度也是 `O(n)`。垃圾回收会导致后续对象，尤其是大对象的内存分配效率变慢。标记整理（Mark Compact）算法可以有效解决这个问题，它会在标记结束后，将被标记的对象向内存的一端移动，最后清理边界的未被标记的内存。

![memory-align](/浅谈%20GC/memory-align.png)

## V8 的分代回收

垃圾清理算法会定时检查内存中所有的对象，并对可达对象进行标记。其问题在于，一些对象常驻内存，可能伴随代码的整个生命周期，频繁检测这一类对象耗费性能。V8 的分代回收对不同类型的对象使用不同的回收机制和频率，很大程度提高了 GC 的效率。

![v8-area](/浅谈%20GC/v8-area.png)

V8 引擎将堆内存分成多个区域，新生代和老生代区域采用不同的策略管理垃圾回收：
- 新生代的对象为新产生的、存活时间较短的对象，新生代通常只支持 `1～8M` 的容量
- 老生代的对象为存活事件较长或常驻内存的对象，它们是经历过新生代垃圾回收后还存活下来的对象，老生代容量通常比较大

新生代对象通过 Scavenge 算法进行 GC，Scavenge 算法主要采用 [Cheney](https://en.wikipedia.org/wiki/Cheney%27s_algorithm) 算法。Cheney 算法将新生代分为 2 个同样大小的空间，处于使用状态的空间称为 `From` ，闲置的空间称为 `To`，产生的新对象进入 `From`：
1. 检查 `From` 是否已满，已满执行 Scavenge 算法
2. 标记 `From` 中的活动对象
3. 标记完成之后，将 `From` 的活动对象复制进 `To` 并进行排序
4. 清理 `From` 区域
5. `From` 和 `to` 角色互换

在执行以上第 3 步时，如果发现：
- 对象已经历过多次复制，直接晋升到老生代
- 对象会占用 `To` 空间 `>=25%` 的大小，晋升到老生代（方便内存分配，防止频繁复制）

老生代中主要是占用空间大，存活时间久的对象，它主要使用标记清除算法进行 GC，并用标记整理算法解决内存碎片化的问题。对老生代的优化主要是增量标记与惰性清理。

## V8 的增量标记与惰性清理

ES 是单线程语言，只有一个主线程，GC 会阻塞脚本的执行，这种行为叫全停顿（Stop The World）。

### 辅助线程

如果执行一次完整 GC 的时间过长，就可能造成运行卡顿。为提高 GC 的效率，V8 采用多个辅助线程同时执行 GC。

![parallel-gc](/浅谈%20GC/parallel-gc.png)

新生代空间就采用辅助线程进行回收，在 GC 过程中，会启动多个线程来负责新生代中的垃圾清理操作，这些线程同时将 `From` 的对象移动到 `To`。在这个过程中，由于对象地址会发生改变，所以还需要同步更新引用这些对象的指针。不过好在这个 GC 过程是一个整体，只需要考虑协同问题。

辅助线程还是一种全停顿的 GC 方式。老生代由于存在的对象多且大，采用辅助线程依然会消耗大量时间。对于老生代空间，V8 采用增量标记进行优化。

### 增量标记

增量标记就是将原本一次完整 **GC 标记**（只是标记，不包括回收）的过程，分成多次与主线程任务交替执行。

![increase-mark](/浅谈%20GC/increase-mark.png)

将一次完整的 GC 标记分次执行造成 2 个主要问题：
- 每一小次 GC 标记执行完之后，如何暂停下来去执行任务程序，而后又怎么恢复？
- 假如在一次完整的 GC 标记分块暂停后，执行任务程序时内存中标记好的对象引用关系被修改了怎么办？

为解决增量标记带来的问题，V8 采用 “三色标记法” 和 “写屏障”。

#### 三色标记法

之前介绍的标记清除将可达性的对象进行标记，不可达对象不予理睬，这实际上一种非黑即白的二色标记法。三色标记法维护一个标记工作表，并对每个对象使用两个标记位进行标记，两个标记位编码白、灰、黑三种颜色：
- 白：未被标记
- 灰：自身被标记，成员对象未被标记
- 黑：自身和成员变量皆被标记

![tri-color-marking](/浅谈%20GC/tri-color-marking.png)

在恢复 GC 标记时，如果没有灰色节点，说明本次 GC 标记工作完成，进入清理阶段，反之需要继续从灰色节点继续进行标记。

##### 强制三色不变性

在一小次 GC 标记后，主线程执行任务时，可能会修改对象的引用关系：

![reference-modification](/浅谈%20GC/reference-modification.png)

上图中的 `C` 对象不再具备可达性，在这一轮的 GC 中，它不会标记和清理，不过完全可以等待下轮 GC 处理它。但是新的对象 `D` 初始是白色，本轮的下一次 GC 标记时，由于没有灰色节点，因此会认为标记结束， `D` 对象会在本轮 GC 的清理阶段被回收。

为防止以上情况的发生，V8 增量回收使用了 “写屏障（Write Barriers）” 机制，即一旦有黑色对象引用白色对象，会强制将该白对象置灰，从而保证本轮的下一次 GC 标记正常执行。这个机制也被称作 “强制三色不变性”。因此，上述情况的 `D` 对象会被强制改为灰色。

### 惰性清理

增量标记只对活动对象和非活动对象进行标记，实际还需要清理释放内存。V8 清理释放内存采用惰性清理（Lazy Sweeping）：增量标记完成后，如果内存空间足够，不影响代码的执行，没有必要立即清理，可以适当延迟清理从而让步于脚本的执行。

### 小结

可以看出，增量标记和惰性清理的引入，并没有减少 GC 占用主线程的时间。实际上 V8 采用 “并发标记”，多个辅助线程在后台完成标记工作，并发的优点是不占用主线程，但多个线程的协同需要锁机制来保障。

![simultaneous](/浅谈%20GC/simultaneous.png)

新生代优化：
- Scavenge 算法
- 辅助线程

老生代优化：
- 并发标记：主线程执行程序任务，辅助线程同时执行标记操作
- 并行清理：主线程执行清理时，多个辅助线程也同时执行清理，这个过程以增量的方式执行



## 识别内存泄漏

在浏览器开发者工具中，使用 Performance 和 Memory 功能，都可以帮助开发者查看内存占用，如果内存占用不是趋于平稳，而是随时间一直上升，则可能发生了内存泄漏。

Node.js 提供的 `process.memoryUsage()` 方法执行后返回一个对象，包含了 Node.js 进程的内存占用信息，该对象包含四个字段，单位是 `Byte`。判断内存泄漏，以 `heapUsed` 字段为准：

```JS
process.memoryUsage()
/*
  {
    rss: 37306368,
    heapTotal: 7892992,
    heapUsed: 6185232,
    external: 1005812,
    arrayBuffers: 17422
  }
*/
```
> - rss（resident set size）：所有内存占用，包括指令区和堆栈
> - heapTotal：“堆” 占用的内存，包括用到的和没用到的
> - heapUsed：用到的堆占用的内存
> - external： V8 引擎内部的 C++ 对象占用的内存
> - arrayBuffers：分配给 `ArrayBuffers` 和 `SharedArrayBuffers` 的内存，包括所有 Node.js 缓冲区
