# 事件流与事件委托

如果 DOM 分为多个层级，每个层级都有绑定事件，当触发最底层 DOM 节点的事件时，高层级的所有 DOM 节点的事件都应该触发。事件触发的顺序需要一套规则来确定，这套规则就是 DOM 事件流。

## 事件流

DOM 中的事件流包括 3 个阶段：
1. 捕获阶段：事件从文档的根节点出发，随着 DOM 树的结构向事件的目标节点流去，途中经过各个层次的 DOM 节点，并在各节点上触发事件回调
2. 目标阶段：目标阶段的事件在目标节点上被触发，执行事件对应的回调
3. 冒泡阶段：事件在目标元素上触发后，会随着 DOM 树一层层向上冒泡直到根节点，途中经过各个层次的 DOM 节点，并在各节点上触发事件回调

通常情况下，事件的触发只需要一次，如果同时在捕获和冒泡阶段触发事件，将导致各层级的事件执行两次，因此任何事件绑定都只能在捕获或冒泡阶段触发事件，而不允许两个阶段同时触发事件。冒泡阶段触发事件相对更加常见，因此事件相关的 API 默认都只在**冒泡阶段**触发事件：
- DOM 元素上直接绑定事件
- `addEventListener(type, listener, useCapture)` 的 `useCapture` 参数缺省为 `false`，即捕获阶段不触发事件

### 阻止事件传播

`event.stopPropagation()` 方法可以阻止事件传播，由于通常采用事件冒泡，因此其作用就是在目标阶段触发事件回调后阻止事件冒泡。

`event.stopImmediatePropagation()` 方法不仅会阻止事件传播，还会阻止该节点的其余同类型事件回调的触发。

### 阻止事件默认行为

给链接绑定点击事件，点击链接会导致跳转，使用 `event.preventDefault()` 可以阻止默认的跳转行为。

### `return false`

在事件回调中使用 `return false` 能同时阻止事件的传播和默认行为。

## 事件委托

现有一个 `<ul>` 列表，通过循环给每一个 `<li>` 元素绑定同一个事件，这样会带来一些问题：
- 多次注册事件，导致更大的内存占用
- 新增的 `<li>` 元素需要手动添加事件绑定

事件委托利用事件冒泡，对原本需要给每一个子元素绑定的事件，只在其父元素上绑定一个事件即可，该事件内部通过 `event.target` 判断触发事件的具体子元素，进行对应的逻辑处理。

`event.target` 表示触发事件的元素，也就是事件最初发生的元素，在事件的捕获和冒泡阶段中，`event.target` 始终不变。

`event.currentTarget` 表示当前正在处理事件的元素，也就是事件当前所在的元素，`event.currentTarget` 会随着事件的传播而改变。


