# 前言

算法（Algorithm）是用来操作数据、解决程序问题的一组方法。同一个问题，常常可以使用多种不同的算法去解，各种算法消耗的资源（CPU 时间占用、内存占用、硬盘占用和网络占用等）往往有很大的区别。通常用 “时间” 和 “空间” 两个维度来衡量不同算法的优劣：
- 时间：指执行算法所消耗的时间
- 空间：指执行算法需要占用的存储空间

## 大 O 表示法

大 O 表示法用法描述算法的时间和空间复杂度，常见阶级：
- `O(1)`：常数
- `O(log(n))`：对数
- `O(n)`：线性
- `O(nlog(n))`：线性对数
- `O(n^k)`：`k` 次方，如 `O(n²)`、`O(n³)` 等
- `O(2^n)`：指数
- `O(n!)`：阶乘

![comparison-computational-complexity](/算法/comparison-computational-complexity.png)

随着问题规模 `n` 的不断增加，算法的复杂度随之增加（除常数阶外），算法的执行效率越低。推导复杂度时的原则：
- 用常数阶 `O(1)` 取代运行时间中的所有加法常数
- 只保留复杂度中的**最高阶项**。比如一个算法中，同时具有 `O(n)` 和 `O(n²)` 两个复杂阶级，严格来说该算法复杂度是 `O(n + n²)`，但一般标记该算法的复杂度是 `O(n²)`
- 如果最高阶项存在，则省去最高阶项前面的常数系数

## 时间复杂度

算法的时间复杂度，实际上是抽象出一种评估指标，获得算法执行所消耗时间的基本趋势。

### 常数阶 `O(1)`

无论代码执行多少行代码，只要没有循环等复杂结构，那么算法的时间复杂度就都是 `O(1)`，如：

```JS
const i = 1
const j = 2
const k = 1 + 2
```

随着问题规模 `n` 的增加，算法执行的时间只是变大的常数。

### 对数阶 `O(log(n))`

```JS
let i = 2 // O(1)
while (i <= n) { // O(log(n))
  i *= 2
}
```

在满足 `2^x <= n` 时，循环体会一直执行，即执行 `x = log(n)` 次之后，才能结束循环。算法的时间复杂度是 `O(1 + log(n))`，最终取最高阶项 `O(log(n))` 标记算法的时间复杂度。

### 线性阶 `O(n)`

```JS
let j = 0 // O(1)
for (let i = 0; i < n; i++) { // O(n)
  j += i // O(n)
}
```

以上循环的时间复杂度是 `O(2n + 1)`，根据推导原则，去掉常数阶和最高阶系数，即 `O(n)`。

### 线性对数阶 `O(nlog(n))`
```JS
for (let m = 0; m < n; m++) { // O(n)
  let i = 2; // O(1)
  while (i <= n) { // O(log(n))
    i = i * 2;
  }
}
```

由于是嵌套循环，因此时间复杂度时 `O(n(1 + log(n)))`，简化 `O(n + nlog(n))`，记作 `O(nlog(n))`。

### 平方阶 `O(n²)`

```JS
let k = 0;
for (let i = 0; i < m; i++) {
  for (let j = 0; j < n; j++) {
    k++;
  }
}
```

上述代码时间复杂度为 `O(m * n)`，如果内外层循环都由 `n` 控制，那么时间复杂度为 `O(n²)`。三层、四层或更多的嵌套循环的时间复杂度一般都归纳为 `O(n^k)`。

## 空间复杂度

空间复杂度主要指执行算法所需内存的大小，用于对程序运行过程中所需要的临时存储空间的度量，这里的空间复杂度同样是抽象预估。常见的空间复杂度阶级和时间复杂度阶级类似，这里举个空间复杂度为 `O(n)` 的例子：


```JS
let j = 0
const m = new Array(n)
for (let i = 0; i < n; ++i) {
  j += i
}
```

上述代码只有前两行声明变量时开辟了存储空间，空间占用量主要取决于 `n` 的大小，因此空间复杂度时 `O(1 + n)`，记作 `O(n)`。

